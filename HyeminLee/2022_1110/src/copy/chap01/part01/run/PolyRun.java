package copy.chap01.part01.run;

// ------------------- 다형성 ---------------------
public class PolyRun {
	
	
	/*
	 * 
	 * 다형성 정리
	 * 
	 * - 다형성 이란?
	 * 		: 부모 - 자식 상속관계에 있는 클래스에서 상위 클래스가 동일한 메시지로 
	 * 		  하위 클래스들을 서로 다르게 동작시키는 객체 지향 원리입니다
	 * 
	 * 근데 어떻게 부모가 자식메소드에 접근해서 호출할수있을까요??
	 * 
	 * 	이유는 "동적 바인딩" 때문이다
	 * 	
	 * 
	 *  - 동적 바인딩이란?
	 *  	: 메소드가 실행시점에서 성격이 결정되는 바인딩
	 *  	 프로그램의 컴파일 시점에 부모 클래스는 자신의 멤버 함수밖에 접근할 수 없으나,
	 *  	 실행 시점에 동적 바인딩이 일어나 부모클래스가 자식 클래스의 멤버함수를 접근하여 실행할 수 있습니다
	 *  
	 *  
	 *  	: 프로그램이 실행되기 전에 컴파일 되면서 정적바인딩 (레퍼런스 타입의 메소드를 가리킴)
	 *  	 단, 실질적으로 참조하는 자식 클래스에 해당 메소드가 오버라이딩이 되어있다면
	 *  		프로그램 실행시 동적으로 그 자식 클래스의 오버라이딩 된 메소드를 찾아서 실행
	 *  	  == 실질적인 타입 (new 클래스타입)의 오버라이딩 메소드를 찾아서 실행
	 *  
	 *  	뭔말이냐?? 부모 - 자식간의 오버라이딩메소드가 있다 과정 (오버라이딩 메소드== 이름만 같고 내용은 수정된)
	 * 
	 * 		부모클래스  객체이름   =  new   자식클래스();
	 * 
	 * 		ex) Parent  p  =  new   Child();
	 * 
	 * 		
	 * 		p.print();  --> print는 부모 - 자식간의 공통적으로 있는 메소드이고, 자식에게는 오버라이딩됐다 가정
	 * 		
	 * 		: 이러면 부모의 print 메소드가 출력되야해! 왜냐면 Child타입으로 강제 형변환 한게 아니니깐!
	 * 		
	 * 		but!! Child1의 print메소드가 출력됨!
	 * 		==> 이게 동적 바인딩이다~  == 실질적인 타입 (new 클래스타입)의 오버라이딩 메소드를 찾아서 실행
	 * 
	 */
	
	
	
	/*
	 * [다형성의 장점]
	 * 
	 * 1. 유지보수가 쉽다
	 * 		: 개발자가 여러 객체를 하나의 타입으로관리가 가능하기 때문에 코드 관리가 편리해 유지보수가 용이
	 * 
	 * 
	 * 2. 재사용성 증가
	 * 		: 다형성을 활용하면 객체를 재사용하기 쉬워지기 때문에 개발자의 코드 재사용성이 높아진다
	 * 
	 * 
	 * 3. 느슨한 결합
	 * 		: 다형성을 활용하면 클래스간 의존성이 줄어들며 확장성이 높고 결합도가 낮아져 안정성이 높아진다
	 * 
	 * 
	 * 
	 * 
	 */
	
	
	
	/*
	 * 
	 * [다형성의 필수 조건]
	 * 
	 * 
	 * 1. 상속 관계
	 * 		: 다형성을 활용하기 위해서는 필수로 부모-자식 간 클래스 상속이 이루어져야 한다.
	 * 
	 * 
	 * 2. 오버라이딩 필수 (자식 클래스에서 메소드 재정의)
	 * 		: 다형성이 보장되기 위해서는 하위 클래스 메소드가 반드시 재정의 되어있어야 한다
	 * 
	 * 
	 * 3. 업캐스팅 (자식 클래스의 객체가 부모 클래스 타입으로 형변환 되는것)
	 * 		: 부모 타입으로 자식클래스를 업 캐스팅하여 객체를 생성해야돼
	 * 		ex) Parent p = new Child();
	 *
	 * 
	 * 
	 */
	
	
	/*
	 * 
	 * [다형성의 구현 방법]
	 * 
	 * 
	 * 1. 상속 클래스 구현 (부모 - 자식 크래스 구현)
	 * 
	 * 		public class Parent {}
	 * 		public class Child {}
	 * 
	 * 
	 * 
	 * 
	 * 2. 메소드 오버라이딩
	 * 
	 * 		public class Parent {
	 * 			public void print() { sysout("부모얌");}
	 * 		}
	 * 		
	 * 
	 * 		@Override
	 *		 public class Child {
	 * 			public void print() { sysout("자식이얌");}
	 * 		}
	 * 
	 * 
	 * 
	 * 3. 업캐스팅하여 객체 선언
	 * 
	 * 		Parent p = new Child();
	 * 
	 * 
	 * 
	 * 4. 부모 클래스 객체로 자식 메소드 호출
	 * 
	 * 		p.print();
	 * 	
	 * 
	 * 
	 */
	
	
	  
	  /*
	   * 
	   *  [객체 타입 확인]
	   *  
	   * 	 instanceof  : 객체 타입 확인하는 연산자
	   * 
	   * 	객체의 실제타입을 알아보기 위한 연산자
	   * 
	   * 
	   * 
	   * 	[표현법]
	   * 
	   * 	if ( A instanceof B ) {
	   * 
	   * 	true시 실행될 코드
	   * 
	   * 	}
	   * 
	   *  A가 B로 만들어진게 맞니?? 객체변수A가 클래스 B타입인게 맞아?
	   *  ==> 맞으면 메소드 실행해!
	   *  
	   *  -- 중첩 가능--
	   *  
	   */
	  
	
	  
	  
	  
	

}//클래스 끝
